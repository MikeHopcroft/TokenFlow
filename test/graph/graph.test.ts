import { assert } from 'chai';
import 'mocha';

import { Edge, allPaths, maximalPaths } from '../../src/graph';
import { Token } from '../../src/tokenizer';

// Returns a string representation of the current path.
// The path is rendered as a sequence of vertices, each of which is
// represented by the letters a, b, c, ...
function pathToString(path: Edge[]) {
    let vertex = 0;
    let text = "";
    for (const edge of path) {
        text = text.concat(String.fromCharCode(97 + vertex));
        vertex += edge.length;
    }
    return text;
}

// Generates the string representation of each path in a graph generated by a
// call to makeEdgeList().
function *allPathStrings(vertexCount: number): IterableIterator<string> {
    const pathCount = 1 << (vertexCount - 1);
    for (let i=0; i < pathCount; ++i) {
        yield pathString(vertexCount, i);
    }
}

function pathString(vertexCount: number, pathNumber: number): string {
    let path = "a";
    for (let i=1; i < vertexCount; ++i) {
        if (pathNumber % 2 === 0) {
            path = path.concat(String.fromCharCode(97 + i));
        }
        pathNumber = pathNumber >> 1;
    }
    return path;
}

const WORD_TOKEN: unique symbol = Symbol('WORD_TOKEN');
type WORD_TOKEN = typeof WORD_TOKEN;

interface WordToken extends Token {
    type: WORD_TOKEN;
    value: string;
}

function wordToken(value: string): WordToken {
    return {
        type: WORD_TOKEN,
        value
    };
}

// Creates an edge list representing a graph with `number` vertices.
// Each vertex has edges to all successive vertices. Edges are scored so that
// longer edges are always preferred over any combination of shorter edges.
function makeEdgeList(vertexCount: number): Edge[][] {
    const edgeList: Edge[][] = [];

    for (let vertex = 0; vertex < vertexCount; ++vertex) {
        const edges: Edge[] = [];
        // const maxLength = vertexCount - vertex;
        for (let length = 1; vertex + length <= vertexCount; ++length) {
            const label = vertex * 10 + vertex + length;
            const token = wordToken(`${vertex} to ${vertex + length}`);

            // Choose score so that longer edge is always preferred over any
            // combination of shorter edges.
            const score = length - Math.pow(0.2, length);

            edges.push({ score, length, token });
        }
        edgeList.push(edges);
    }

    return edgeList;
}


function printGraph(edgeLists: Edge[][]) {
    for (const [i, edges] of edgeLists.entries()) {
        console.log(`Vertex ${i}:`);
        for (const edge of edges) {
            console.log(`  score: ${edge.score}, length: ${edge.length}, label: ${(edge.token as WordToken).value}`);
        }
    }
}

describe('Graph', () => {
    // This test verifies that a walk of DynamicGraph generates the expected
    // number of paths. It does not verify that the paths are correct, unique,
    // or in the right order.
    it('allPaths() count is correct', () => {
        const vertexCount = 6;
        const edgeList: Edge[][] = makeEdgeList(vertexCount);

        const observedPathCount = [...allPaths(edgeList)].length;
        const expectedPathCount = Math.pow(2, vertexCount - 1);

        assert.equal(observedPathCount, expectedPathCount);
    });

    // This test verifies that a walk of a specific DynamicGraph generates the
    // expected sequence of paths.
    it('allPaths() enumeration is correct', () => {
        const vertexCount = 6;
        const edgeList: Edge[][] = makeEdgeList(vertexCount);
        const observed = [...allPaths(edgeList)].map(pathToString).sort();

        const expected = [...allPathStrings(vertexCount)].sort();

        assert.deepEqual(observed, expected);
    });

    it('maximalPaths() count is correct', () => {
        const vertexCount = 6;
        const edgeList: Edge[][] = makeEdgeList(vertexCount);
        const observed1 = [...maximalPaths(edgeList)].map(pathToString).length;

        assert.equal(observed1, 1);

        const edge2 = {
            ...edgeList[0][vertexCount - 1],
            token: wordToken('extra')
        };
        edgeList[0].push(edge2);
        const observed2 = [...maximalPaths(edgeList)].map(pathToString).length;
        assert.equal(observed2, 2);
    });

    it('maximalPaths() enumeration is correct', () => {
        const vertexCount = 6;
        const edgeList: Edge[][] = makeEdgeList(vertexCount);
        const observed1 = [...maximalPaths(edgeList)].map(pathToString);

        assert.deepEqual(observed1, ["a"]);

        const edge2 = {
            ...edgeList[0][vertexCount - 1],
            token: wordToken('extra')
        };
        edgeList[0].push(edge2);
        const observed2 = [...maximalPaths(edgeList)].map(pathToString);
        assert.deepEqual(observed2, ["a", "a"]);

        // TODO: construct a graph with two really different maximal paths.
        // const edge3 = {
        //     ...edgeList[0][vertexCount - 1],
        //     token: wordToken('extra'),
        //     length: vertexCount - 3
        // };
        // edgeList[1].push(edge3);
        // const observed3 = [...maximalPaths(edgeList)].map(pathToString);
        // assert.deepEqual(observed3, ["a", "a", "ab"]);
    });
});
